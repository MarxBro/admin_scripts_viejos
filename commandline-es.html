<p>[ Languages: <a href="README.md">English</a>, <a href="README-es.md">Español</a>, <a href="README-it.md">Italiano</a>, <a href="README-ja.md">日本語</a>, <a href="README-ko.md">한국어</a>, <a href="README-pt.md">Português</a>, <a href="README-ru.md">Русский</a>, <a href="README-sl.md">Slovenščina</a>, <a href="README-uk.md">Українська</a>, <a href="README-zh.md">中文</a>]</p>
<h1 id="el-arte-del-terminal">El Arte del Terminal</h1>
<p><a href="https://gitter.im/jlevy/the-art-of-command-line?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/jlevy/the-art-of-command-line" /></a></p>
<ul>
<li><a href="#meta">Meta</a></li>
<li><a href="#fundamentos">Fundamentos</a></li>
<li><a href="#de-uso-diario">Uso diario</a></li>
<li><a href="#procesamiento-de-archivos-y-datos">Procesamiento archivos y datos</a></li>
<li><a href="#depuración-del-sistema">Depuración del sistema</a></li>
<li><a href="#one-liners">One-liners</a></li>
<li><a href="#osbcuro-pero-útil">Obscuro pero útil</a></li>
<li><a href="#solo-para-os-x">Solo para OS X</a></li>
<li><a href="#más-recursos">Más recursos</a></li>
<li><a href="#advertencia">Advertencia</a></li>
</ul>
<div class="figure">
<img src="cowsay.png" alt="curl -s &#39;https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md&#39; | egrep -o &#39;\w+&#39; | tr -d &#39;`&#39; | cowsay -W50" />
<p class="caption">curl -s 'https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md' | egrep -o '<code>\w+</code>' | tr -d '`' | cowsay -W50</p>
</div>
<p>La fluidez en el terminal es una destreza a menudo abandonada y considerada arcaica, pero esta mejora su flexibilidad y productividad como ingeniero en formas obvia y sutil. Esta es una selección de notas y consejos al usar el terminal que encontramos útiles al trabajar en Linux. Algunos consejos son elementales y algunos bastante específicos, sofisticados u oscuros. Esta página no es larga, pero si puedes usar y recordar todos los puntos aquí mostrados, sabrás un montón.</p>
<p>Este trabajo es el resultado de <a href="AUTHORS.md">muchos autores y traductores</a>. La mayor parte <a href="http://www.quora.com/What-are-some-lesser-known-but-useful-Unix-commands">originalmente</a> <a href="http://www.quora.com/What-are-the-most-useful-Swiss-army-knife-one-liners-on-Unix">apareció</a> en <a href="http://www.quora.com/What-are-some-time-saving-tips-that-every-Linux-user-should-know">Quora</a>, pero debido al interés mostrado, parecía valer la pena usar Github, donde personas más talentosas que el autor original pudiendo fácilmente sugerir mejoras. Si ve un error o algo que podría ser mejor, por favor, crea un issue o PR! (Por supuesto primero revisa la sección meta de PRs/issues.)</p>
<h2 id="meta">Meta</h2>
<p>Alcance:</p>
<ul>
<li>Esta guía es tanto para principiantes como para experimentados. Los objetivos son <em>diversidad</em> (todo importa), <em>especificidad</em> (dar ejemplos concretos del caso más común), y <em>concisión</em> (evitar cosas que no son esenciales o insignificantes que puedas buscar fácilmente en otro lugar). Cada consejo es esencial en alguna situación o significativamente puede ahorrar tiempo comparado con otras alternativas.</li>
<li>Esta escrito para Linux, con excepción de la sección &quot;<a href="#os-x-only">Solo para OS X</a>&quot;. Muchos de los otros puntos aplican o pueden ser instalados en otros Unices o MacOS (o incluso Cygwin).</li>
<li>Se enfoca en Bash interactivo, aunque muchos de los consejos se aplican para otros shells y al Bash scripting por lo general.</li>
<li>Incluye tanto comandos &quot;estándar&quot; Unix, así como aquellos que requieren la instalación especial de un paquete -- siempre que sea suficientemente importante para ameritar su inclusión.</li>
</ul>
<p>Notas:</p>
<ul>
<li>Para mantener esto en una página, el contenido está incluido implícitamente por referencia. Eres lo suficientemente inteligente para consultar más detalles en otros lugares, cuando conoces la idea o comando con Google. Usa <code>apt-get</code>/<code>yum</code>/<code>dnf</code>/<code>pacman</code>/<code>pip</code>/<code>brew</code> (según proceda) para instalar los nuevos programas.</li>
<li>Usa <a href="http://explainshell.com/">Explainshell</a> para obtener detalles de ayuda sobre que comandos, opciones, pipes, etc.</li>
</ul>
<h2 id="fundamentos">Fundamentos</h2>
<ul>
<li><p>Aprende conocimientos básicos de Bash, de hecho, escribe <code>man bash</code> y al menos échale un vistazo a todo el asunto. Es bastante fácil de seguir y no es tan largo. Alternar entre shells puede ser agradable, pero Bash es poderoso y siempre está disponible (conocer <em>solo</em> zsh, fish, etc., aunque resulte tentador en tu propia laptop, Te restringe en muchas situaciones, tales como el uso de servidores existentes).</p></li>
<li><p>Aprende bien al menos un editor de texto, idealmente Vim (<code>vi</code>), como no hay realmente una competencia para la edición aleatoria en un terminal (incluso si usa Emacs, un gran IDE, o un editor alternativo (hipster) moderno la mayor parte del tiempo).</p></li>
<li><p>Conoce como leer la documentación con <code>man</code> (Para curiosos, <code>man man</code> lista las secciones enumeradas, ej. 1 es comandos &quot;regulares&quot;, 5 son archivos/convenciones, y 8 para administración). Encuentra las páginas de man <code>apropos</code>. Sepa que alguno de los comandos no son ejecutables, pero son Bash builtins, y que puedes obtener ayuda sobre ellos con <code>help</code> y <code>help -d</code>.</p></li>
<li><p>Aprende sobre redirección de salida <code>&gt;</code>, entrada <code>&lt;</code> y pipes utilizando <code>|</code>. Conozca que <code>&gt;</code> sobrescribe el archivo de salida y <code>&gt;&gt;</code> añade. Aprende sobre stdout y stderr.</p></li>
<li><p>Aprende sobre expansión de archivos glob con <code>*</code> (y tal vez <code>?</code> y <code>[</code>...<code>]</code>) y quoting y la diferencia entre comillas dobles <code>&quot;</code> y simples <code>'</code>. (Ver más en expansión de variables más abajo.)</p></li>
<li><p>Familiarízate con la administración de trabajo en Bash: <code>&amp;</code>, <strong>ctrl-z</strong>, <strong>ctrl-c</strong>, <code>jobs</code>, <code>fg</code>, <code>bg</code>, <code>kill</code>, etc.</p></li>
<li><p>Conoce <code>ssh</code> y lo básico de autenticación sin contraseña, vía <code>ssh-agent</code>, <code>ssh-add</code>, etc.</p></li>
<li><p>Administración de archivos básica: <code>ls</code> y <code>ls -l</code> (en particular, aprende el significado de cada columna en <code>ls -l</code>), <code>less</code>, <code>head</code>, <code>tail</code> y <code>tail -f</code> (o incluso mejor, <code>less +F</code>), <code>ln</code> y <code>ln -s</code> (aprende las diferencias y ventajas entre enlaces hard y soft), <code>chown</code>, <code>chmod</code>, <code>du</code> (para un resumen rápido del uso del disco: <code>du -hs *</code>). Para administración de archivos de sistema, <code>df</code>, <code>mount</code>, <code>fdisk</code>, <code>mkfs</code>, <code>lsblk</code>. Aprenda que un inode es <code>ls -i</code> or <code>df -i</code>).</p></li>
<li><p>Administración básica de redes: <code>ip</code> o <code>ifconfig</code>, <code>dig</code>.</p></li>
<li><p>Conoce bien las expresiones regulares y varias opciones (flags) para <code>grep</code>/<code>egrep</code>. Las opciones <code>-i</code>, <code>-o</code>, <code>-v</code>, <code>-A</code>, <code>-B</code> y <code>-C</code> son dignas de ser recordadas.</p></li>
<li><p>Aprende el uso de <code>apt-get</code>, <code>yum</code>, <code>dnf</code> o <code>pacman</code> (dependiendo de la distribución &quot;distro&quot;) para buscar e instalar paquetes. Y asegúrate que tienes <code>pip</code> para instalar la herramienta de línea de comando basada en Python (un poco más abajo esta explicado como instalar vía <code>pip</code>).</p></li>
</ul>
<h2 id="de-uso-diario">De uso diario</h2>
<ul>
<li><p>En Bash, se usa <strong>Tab</strong> para completar los argumentos o lista todos los comandos disponibles y <strong>ctrl-r</strong> para buscar a través del historial de comandos (despues de presionar, escribe la búsqueda, presiona <strong>ctrl-r</strong> repetidamente para hacer un ciclo a través de más coincidencias, presiona <strong>Enter</strong> para ejecurar el comando encontrado, o presiona la flecha derecha para poner el resultado en la línea actual y editar).</p></li>
<li><p>En Bash, se usa <strong>ctrl-w</strong> para borrar la última palabra, y <strong>ctrl-u</strong> para borrar todo hacia atrás hasta el inicio de la línea. Se usa <strong>alt-b</strong> y <strong>alt-f</strong> para moverse entre palabras, <strong>ctrl-a</strong> para mover el cursor al principio de la línea, <strong>ctrl-e</strong> para mover el cursor al final de la línea, <strong>ctrl-k</strong> para eliminar hasta el final de la línea, <strong>ctrl-l</strong> para limpiar la pantalla. Ver <code>man readline</code> para todos los atajos de teclado por defecto en Bash. Son una gran cantidad. Por ejemplo <strong>alt-.</strong> realiza un ciclo a través de los comandos previos, y <strong>alt-</strong>* expande un glob.</p></li>
<li><p>Alternativamente, si amas los atajos de teclado vi-style, usa <code>set -o vi</code>. (y <code>set -o emacs</code> para regresar a la anterior).</p></li>
<li><p>Para editar largos comandos, después de configurar to editor (por ejemplo <code>export EDITOR=vim</code>), <strong>ctrl-x</strong> <strong>ctrl-e</strong> se abrirá el comando actual en un editor para editar multiples líneas. O en estilo vi, <strong>escape-v</strong>.</p></li>
<li><p>Para ver los últimos comandos, <code>history</code>. También existen abreviaciones, tales como, <code>!$</code> (último argumento) y <code>!!</code> último comando, aunque son fácilmente remplazados con <strong>ctrl-r</strong> y <strong>alt-.</strong>.</p></li>
<li><p>Para volver al directorio de trabajo previo: <code>cd -</code></p></li>
<li><p>Si estás a medio camino al escribir un comando pero cambias de opinión, presiona <strong>alt-#</strong> para agregar un <code>#</code> al principio y lo agrega como comentario (o usa <strong>ctrl-a</strong>, <strong>#</strong>, <strong>enter</strong>). Luego puedes regresar a este vía comando <code>history</code>.</p></li>
<li><p>Usa <code>xargs</code> (o <code>parallel</code>). Es muy poderoso. Ten en cuenta que puedes controlar cuántos elementos son ejecutados por línea (<code>-L</code>), así como el paralelismo (<code>-P</code>). Si no estas seguro de que este haga la cosa correcta, usa <code>xargs echo</code> primero. También, <code>-I{}</code> es útil. Ejemplos:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">  <span class="kw">find</span> . -name <span class="st">&#39;*.py&#39;</span> <span class="kw">|</span> <span class="kw">xargs</span> grep some_function
  <span class="kw">cat</span> hosts <span class="kw">|</span> <span class="kw">xargs</span> -I<span class="dt">{}</span> ssh root@<span class="dt">{}</span> hostname</code></pre></div></li>
<li><p><code>pstree -p</code> es útil para mostrar el árbol de procesos.</p></li>
<li><p>Usa <code>pgrep</code> y <code>pkill</code> para encontrar o señalar procesos por su nombre (<code>-f</code> es de mucha ayuda).</p></li>
<li><p>Conoce las señales que puedes enviar a los procesos. Por ejemplo, para suspender un proceso usa <code>kill -STOP [pid]</code>. Con <code>man 7 signal</code> puedes ver la lista completa</p></li>
<li><p>Usa <code>nohup</code> o <code>disown</code> si quieres que un proceso de fondo se mantenga corriendo para siempre.</p></li>
<li><p>Verifica que procesos están escuchando vía <code>netstat -lntp</code> o <code>ss -plat</code> (para TCP; agrega <code>-u</code> para UDP).</p></li>
<li><p>Consulta también <code>lsof</code> para abrir sockets y archivos.</p></li>
<li><p>Consulta <code>uptime</code> o <code>w</code> para conocer cuánto tiempo el sistema ha estado corriendo.</p></li>
<li><p>Usa <code>alias</code> para crear atajos para comandos comúnmente usados. Por ejemplo, <code>alias ll=&quot;las -latr&quot;</code> crea el alias <code>ll</code></p></li>
<li><p>En Bash scripts, usa <code>set -x</code> (o su variantes <code>set -v</code>, que registra las entradas sin procesar, incluyendo variables sin expander y comantarios) para depurar la salida. Usa el modo estricto al menos que tengas una buena razón para no hacerlo: Usa <code>set -e</code> para abortar en caso de errores (códigos de salida distintos a cero). Usa <code>set -u</code> para detectar uso de variables no definidas. Considera <code>set -o pipefail</code> también, para los errores con pipes, también (estudiar mas sobre este como un tema delicado). Para scripts más complejos, usa también <code>trap</code>. en EXIT o ERR. Un hábito útil es para comenzar un script como este, el cual detectará y abortará con errores comunes e imprimirá un mensaje:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">set</span> <span class="kw">-euo</span> pipefail
<span class="kw">trap</span> <span class="st">&quot;echo &#39;error: Falló del Script: ver arriba comando que falló&#39;&quot;</span> ERR</code></pre></div></li>
<li><p>En Bash scripts, subshells (escritos con paréntesis) son maneras convenientes para agrupar los comandos. Un ejemplo común es temporalmente moverse hacia un directorio de trabajo diferente, Ej.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">  <span class="co"># do something in current dir</span>
  <span class="kw">(cd</span> /some/other/dir <span class="kw">&amp;&amp;</span> <span class="kw">other-command)</span>
  <span class="co"># continue in original dir</span></code></pre></div></li>
<li><p>En Bash, considera que hay muchas formas de expansión de variables. Verificar la existencia de una variable: <code>${name:?error message}</code>. Por ejemplo, si un script Bash requiere un único argumento, solo escribe <code>input_file=${1:?usage: $0 input_file}</code>. Expansión aritmética: <code>i=$(( (i + 1) % 5 ))</code>. Secuencias: <code>{1..10}</code>. Reducción de cadenas de texto: <code>${var%suffix}</code> y <code>${var#prefix}</code>. Por ejemplo si <code>var=foo.pdf</code>, entonces <code>echo ${var%.pdf}.txt</code> imprime <code>foo.txt</code>.</p></li>
<li><p>Utilizando la expansión de corchetes <code>{</code>...<code>}</code> puede reducir el tener que retipear un texto similar y automatizar conbinaciones de elementos. Esto es útil en ejemplos como <code>mv foo.{txt,pdf} some-dir</code> (el cual mueve ambos archivos), <code>cp somefile{,.bak}</code> (el cual se expandirá a <code>cp somefile somefile.bak</code>) o <code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code> (el cual se expandirá en todas las posibles conbinaciones y creará un árbol de directorios).</p></li>
<li><p>La salida de un comando puede ser tratado como un archivo por medio de <code>&lt;(some command)</code>. Por ejemplo, comparar el <code>/etc/hosts</code> local con uno remoto:</p>
<pre class="sh"><code>  diff /etc/hosts &lt;(ssh somehost cat /etc/hosts)</code></pre></li>
<li><p>Conocer acerca de &quot;here documents&quot; en Bash, como también de <code>cat &lt;&lt;EOF ...</code>.</p></li>
<li><p>En Bash, redirecciona ambas la salida estándar y el error estándar, mediante: <code>some-command &gt;logfile 2&gt;&amp;1</code> o <code>some-command &amp;&gt;logfile</code>. Frecuentemente, para garantizar que un comando no haya dejado abierto un archivo para controlar la entrada estándar vinculada al terminal en el que te encuentras y también como buena práctica puedes agregar <code>&lt;/dev/null</code>.</p></li>
<li><p>Usa <code>man ascii</code> para una buena tabla ASCII con valores hexadecimal y decimales. Para información de codificación general, <code>man unicode</code>, <code>man utf-8</code>, y <code>man latin1</code> son de utilidad.</p></li>
<li><p>Usa <code>screen</code> o <a href="https://tmux.github.io/"><code>tmux</code></a> para multiplexar la pantalla, especialmente útil en sesiones ssh remotas y para desconectar y reconectar a una sesión. <code>byobu</code> puede mejorar la pantalla o tmux proporcionando mayor información y gestión ás sencilla. Una alternativa más minimalista para persistencia de la sesión solo sería <code>dtach</code>.</p></li>
<li><p>En ssh, saber cómo hacer un port tunnel con <code>-L</code> o <code>-D</code> (y de vez en cuando <code>-R</code>) es útil, Ej. para acceder a sitios web desde un servidor remoto.</p></li>
<li><p>Puede ser útil hacer algunas optimizaciones a su configuración ssh; por ejemplo, <code>~/.ssh/config</code>, contiene la configuración para evitar desconexiones en ciertos entornos de red, utiliza compresión (cual es útil con scp sobre conexiones con un bajo ancho de banda), y la multiplexión de canales para el mismo servidor con un archivo de control local:</p>
<pre><code>  TCPKeepAlive=yes
  ServerAliveInterval=15
  ServerAliveCountMax=6
  Compression=yes
  ControlMaster auto
  ControlPath /tmp/%r@%h:%p
  ControlPersist yes</code></pre></li>
<li><p>Algunas otras opciones relevantes a ssh son sensibles en cuanto a seguridad y deben ser usadas con cuidado, Ej. por subnet, host o en redes confiables: <code>StrictHostKeyChecking=no</code>, <code>ForwardAgent=yes</code>.</p></li>
<li><p>Considera <a href="https://mosh.mit.edu/"><code>mosh</code></a> una alternativa para ssh que utiliza UDP, evitando conexiones caidas y agregando conveniencia en el camino. (require configuración del lado del servidor).</p></li>
<li><p>Para obtener permiso sobre un archivo en forma octal, el cual es útil para la configuración del sistema pero no está disponible con <code>ls</code> y fácil de estropear, usa algo como</p>
<pre class="sh"><code>  stat -c &#39;%A %a %n&#39; /etc/timezone</code></pre></li>
<li><p>Para selección interactiva de valores desde la salida de otro comando, use <a href="https://github.com/mooz/percol"><code>percol</code></a> o <a href="https://github.com/junegunn/fzf"><code>fzf</code></a>.</p></li>
<li><p>Para la interacción con archivos basados en la salida de otro comando (como <code>git</code>), use <code>fpp</code> (<a href="https://github.com/facebook/PathPicker">PathPicker</a>).</p></li>
<li><p>Para un servidor web sencillo para todos los archivos en el directorio actual (y subdirectorios), disponible para cualquiera en tu red, usa: <code>python -m SimpleHTTPServer 7777</code> (para el puerto 7777 y Python 2) y <code>python -m http.server 7777</code> (para 7777 y Python 3).</p></li>
<li><p>Para ejecutar un comando con privilegios, usando <code>sudo</code> (para root) o <code>sudo -u</code> (para otro usuario). Usa <code>su</code> o <code>sudo bash</code> para realmente ejecutar un shell como este usuario. Usa <code>su -</code> para simular un login fresco como root u otro usuario.</p></li>
</ul>
<h2 id="procesamiento-de-archivos-y-datos">Procesamiento de archivos y datos</h2>
<ul>
<li><p>Para localizar un archivo por nombre en el directorio actual, <code>find . -iname '*algo*'</code> (o similar). Para encontrar un archivo en cualquier lado por nombre, usa <code>locate something</code> (pero tenga en mente que <code>updatedb</code> quizás no haya indexado recientemente los archivos creados).</p></li>
<li><p>Para búsqueda general a través de archivos fuente o de datos (más avanzado que <code>grep -r</code>), usa <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a>.</p></li>
<li><p>Para convertir HTML a texto: <code>lynx -dump -stdin</code></p></li>
<li><p>Para Markdown, HTML, y todos los tipos de conversión de documentos, prueba <a href="http://pandoc.org/"><code>pandoc</code></a>.</p></li>
<li><p>Si debe manipular XML, <code>xmlstarlet</code> es viejo pero bueno.</p></li>
<li><p>Para JSON usa <a href="http://stedolan.github.io/jq/"><code>jq</code></a>.</p></li>
<li><p>Para YAML, usa <a href="https://github.com/0k/shyaml"><code>shyaml</code></a>.</p></li>
<li><p>Para archivos Excel o CSV, <a href="https://github.com/onyxfish/csvkit">csvkit</a> proporciona <code>in2csv</code>, <code>csvcut</code>, <code>csvjoin</code>, <code>csvgrep</code>, etc.</p></li>
<li><p>Para Amazon S3, <a href="https://github.com/s3tools/s3cmd"><code>s3cmd</code></a> es conveniente y <a href="https://github.com/bloomreach/s4cmd"><code>s4cmd</code></a> es el mas rápido. <a href="https://github.com/aws/aws-cli"><code>aws</code></a> de Amazon y el mejorado <a href="https://github.com/donnemartin/saws"><code>saws</code></a> son esenciales para otras tareas relacionadas al AWS.</p></li>
<li><p>Conoce acerca de <code>sort</code> y <code>uniq</code>, incluyendo las opciones de uniq <code>-u</code> y <code>-d</code> -- ver <a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-es.md#one-liners">one-liners</a> más abajo. Ver también <code>comm</code></p></li>
<li><p>Conoce acerca de <code>cut</code>, <code>paste</code> y <code>join</code> para manipular archivos de texto. Muchas personas usan <code>cut</code> pero se olvidan acerca de <code>join</code>.</p></li>
<li><p>Conoce acerca de <code>wc</code> para contar saltos de línea (<code>-l</code>), caracteres (<code>-m</code>), palabras (<code>-w</code>) y bytes (<code>-c</code>).</p></li>
<li><p>Conoce acerca de <code>tee</code> para copiar desde el stdin hacia un archivo y también hacia el stdout, al igual que en <code>ls -al | tee file.txt</code>.</p></li>
<li><p>Conoce que la localización afecta muchas herramientas de línea de comando en forma delicada, incluyendo el ordenamiento (compaginación) y rendimiento. La mayoría de las instalaciones de Linux configuran <code>LANG</code> u otras variables de localización para la configuración local como US English. Pero ten en mente que el ordenamiento puede cambiar si cambia la localización. Y también las rutinas i18n pueden hacer que <code>sort</code> u otros comandos se ejecuten más lentamente. En algunas situaciones (tales como la realización de operaciones u operaciones singulares descritas más abajo) puedes ignorar las rutinas i18n por completo y utilizar el sort tradicional basado en bytes, usando <code>export LC_ALL=C</code>.</p></li>
<li><p>Conoce los aspectos básicos de <code>awk</code> y <code>sed</code> para manejo de datos. Por ejemplo, sumar todos lo números en la tercera columna de un archivo de texto: <code>awk '{ x += $3 } END { print x }'</code>. Esto es probablemente 3 veces más rápido y 3 veces más corto que su equivalente en Python.</p></li>
<li><p>Para reemplazar todas las ocurrencias de un string en su lugar, en uno o más archivos:</p>
<pre class="sh"><code>  perl -pi.bak -e &#39;s/old-string/new-string/g&#39; my-files-*.txt</code></pre></li>
<li><p>Para renombrar multiples y/o buscar y remplazar dentro de archivos, intenta <a href="https://github.com/jlevy/repren"><code>repren</code></a>. (En algunos casos el comando <code>rename</code> también permite multiples renombramientos, pero sea cuidadoso ya que esta funcionalidad no es igual en todas las distribuciones de Linux.)</p>
<pre class="sh"><code>  # Renombramiento completo de archivos, carpetas y contenidos foo -&gt; bar:
  repren --full --preserve-case --from foo --to bar .
  # Recuperar archivos de respaldo cualquier.bak -&gt; cualquier:
  repren --renames --from &#39;.*)\.bak&#39; --to &#39;\1&#39; *.bak
  # Igual que arriba, utilizando rename, si esta disponible:
  rename &#39;s/\.bak$//&#39; *.bak</code></pre></li>
<li><p>Como dice la página de man, <code>rsync</code> es una muy rápida y extraordinariamente versatil herramienta de copiado. Esta se conoce por la sincronización entre máquinas pero es igualmente útil localmente. Esta también se encuentra entre las <a href="https://web.archive.org/web/20130929001850/http://linuxnote.net/jianingy/en/linux/a-fast-way-to-remove-huge-number-of-files.html">formas más rápidas</a> para borrar un gran número de archivos:</p>
<pre class="sh"><code>mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir</code></pre></li>
<li><p>Usa <code>shuf</code> para mezclar o seleccionar líneas aleatorias de un archivo.</p></li>
<li><p>Conoce las opciones de <code>sort</code>. Para números, usa <code>-n</code>, o <code>-h</code> para manipulación de números humanamente leíbles (Ej. desde <code>du -h</code>). Conoce el trabajo principal de (<code>-t</code> y <code>-k</code>). En particular, esta atento que lo necesitas escribir<code>-k1,1</code> para ordenar por solo el primer campo; <code>-k1</code> significa ordenar de acuerdo a toda la línea. Orden estable (<code>sort -s</code>) puede ser útil. Por ejemplo, para organizar el primer por el campo 2, entonces secundariamente hacerlo por el campo 1, Puedes usar <code>sort -k1,1 | sort -s -k2,2</code>.</p></li>
<li><p>Si alguna vez necesitas escribir un tab literal en una línea de comandos en Bash (Ej. para el argumento -t de ordenar), presiona <strong>ctrl-v</strong> <strong>[Tab]</strong> o escribe <code>$'\t'</code> (El último es mejor porque puedes copiarlo/pegarlo).</p></li>
<li><p>Las herramientas estándar para reparar el código fuente son <code>diff</code> y <code>patch</code>. Consulta también <code>diffstat</code> para resumen estadístico de una diff y <code>sdiff</code> para un diff puesto lado a lado. Considera <code>diff -r</code> trabaja con directorios por completo. Usa <code>diff -r tree1 tree2 | diffstat</code> para el resumen de cambios. Urilizá <code>vimdiff</code> para comparar y editar archivos.</p></li>
<li><p>Para archivos binarios, usa <code>hd</code>, <code>hexdeump</code> or <code>xxd</code> para volcados hexdecimales simples y <code>bvi</code> o <code>biew</code> para edición de binario.</p></li>
<li><p>También para archivos binarios, <code>strings</code> (además de <code>grep</code>, etc.) permite encontrar fragmentos de texto.</p></li>
<li><p>Para diffs binaria (compresión delta), usa <code>xdelta3</code>.</p></li>
<li><p>Para convertir la codificación del texto, probar <code>iconv</code>. O <code>uconv</code> para uso más avanzado; este soporta algunos elementos Unicode avanzados. Por ejemplo, este comando coloca en minúsculas y remueve todas los acentos (por su expansión y colocándolos):</p>
<pre class="sh"><code>  uconv -f utf-8 -t utf-8 -x &#39;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#39; &lt; input.txt &gt; output.txt</code></pre></li>
<li><p>Para dividir archivos en múltiples partes, consulta <code>split</code> (para dividir por tamaño) y <code>csplit</code> (para dividir por un patrón).</p></li>
<li><p>Para manipular expresiones de fecha y tiempo, usa <code>dateadd</code>, <code>datediff</code>, <code>strptime</code> etc. de <a href="http://www.fresse.org/dateutils/"><code>dateutils</code></a>.</p></li>
<li><p>Usa <code>zless</code>, <code>zmore</code>, <code>zcat</code>, y <code>zgrep</code> para operar sobre archivos comprimidos.</p></li>
</ul>
<h2 id="depuración-del-sistema">Depuración del sistema</h2>
<ul>
<li><p>Para depuración web, <code>curl</code> y <code>curl -I</code> son prácticos, o como sus equivalentes <code>wget</code>, o el más moderno <a href="https://github.com/jkbrzt/httpie"><code>httpie</code></a>.</p></li>
<li><p>Para conocer el estado del cpu/disco, las clásicas herramientas son <code>top</code> (o mejor <code>htop</code>), <code>iostat</code>, y <code>iotop</code>. Usa <code>iostat -mxz 15</code> para CPU básicas y estadísticas detalladas y visión de rendimiento por partición del disco.</p></li>
<li><p>Para detalles de la conexión de red, usa <code>netstat</code> y <code>ss</code>.</p></li>
<li><p>Para una rápida visión general de que esta pasando en un sistema, <code>dstat</code> es especialmente útil. Para una visión general más amplia con detalles usa <a href="https://github.com/nicolargo/glances"><code>glances</code></a>.</p></li>
<li><p>Para conocer el estado de la memoria, ejecuta y entiende la salida de <code>free</code> y <code>vmstat</code>. En particular, ten en cuenta que el valor &quot;cached&quot; es mantenido en memoria por el kernel de Linux como un archivo de cache, por lo que efectivamente cuenta como valor para &quot;free&quot;.</p></li>
<li><p>El sistema de depuración de Java es harina de otro costal, pero un truco simple en las JSM de Oracle y otros consta en que puedes ejecutar <code>kill -3 &lt;pid&gt;</code> y una traza completa y un resumen del montículo &quot;heap summary&quot; (incluyendo del detalle de la colección de basura generacional, la cual puede ser altamente informativa) serán descargados al stderr/logs. Las herramientas <code>jps</code>, <code>jstat</code>, <code>jstack</code>, <code>jmap</code> del JDK son útiles. <a href="https://github.com/aragozin/jvm-tools">SJK tools</a> son más avanzadas.</p></li>
<li><p>Usa <code>mtr</code> como un mejor traceroute para identificar los problemas en la red.</p></li>
<li><p>Para examinar por qué el disco está lleno, <code>ncdu</code> ahorra tiempo en comparación con los comandos usuales como <code>du -sh *</code>.</p></li>
<li><p>Para encontrar cual socket o proceso está utilizando el ancho de banda, prueba <code>iftop</code> o <code>nethogs</code>.</p></li>
<li><p>La herramienta <code>ab</code> (viene con Apache) es útil para una verificación rápida del rendimiento de un servidor web. Para pruebas de carga más complejas prueba <code>siege</code>.</p></li>
<li><p>Para una depuración mas seria de redes, <code>wireshark</code>, <code>tshark</code>, o <code>ngrep</code>.</p></li>
<li><p>Conoce acerca de <code>strace</code> y <code>ltrace</code>. Estas puede ser de utilidad si un programa está fallando, suspendido, o colgado, y no sabe por qué, o si quieres tener una idea general del rendimiento. Considera la opción de elaboración de perfiles (<code>-c</code>), y la habilidad de adjuntar a un proceso en ejecución (<code>-p</code>).</p></li>
<li><p>Conoce acerca <code>ldd</code> para verificar librerías compartidas etc.</p></li>
<li><p>Conoce como conectarse a un proceso en ejecución con <code>gdb</code> y obtener su traza de pilas.</p></li>
<li><p>Usa <code>/proc</code>. Es extraordinariamente útil algunas veces cuando se depuran problemas en vivo. Ejemplos: <code>/proc/cpuinfo</code>, <code>/proc/xxx/cwd</code>, <code>/proc/meminfo</code>, <code>/proc/cmdline</code>, <code>/proc/xxx/exe</code>, <code>/proc/xxx/fd/</code>, <code>/proc/xxx/smaps</code> (donde <code>xxx</code> es el id o pid del proceso).</p></li>
<li><p>Cuando se depura porque algo salió mal en el pasado, <code>sar</code> puede ser muy útil. Este muestra la estadística histórica en CPU, memoria, red, etc.</p></li>
<li><p>Para sistemas y análisis de rendimiento de mayor profundidad, examina <code>stap</code> (<a href="https://sourceware.org/systemtap/wiki">SystemTap</a>), <a href="https://en.wikipedia.org/wiki/Perf_(Linux)"><code>perf</code></a>, y <a href="https://github.com/draios/sysdig"><code>sysdig</code></a>.</p></li>
<li><p>Comprueba en que OS se encuentra con <code>uname</code> o <code>uname -a</code> (información general en Unix/kernel) o <code>lsb_release -a</code> (información en Linux distro).</p></li>
<li><p>Usa <code>dmesg</code> siempre que algo actúe raro (esto podría ser problemas con el hardware o driver).</p></li>
</ul>
<h2 id="one-liners">One-liners</h2>
<p>Algunos ejemplos de comandos reunidos:</p>
<ul>
<li><p>Es notablemente útil en ocasiones que pueda realizar intersección, unión, y diferencia de conjuntos de archivos de texto vía <code>sort</code>/<code>uniq</code>. Suponga que <code>a</code> y <code>b</code> como archivos de texto que son únicos. Esto es rápido, y trabaja con archivos de tamaño arbitrario, hasta varios gigabytes. (Sort no está limitado por la memoria, aunque quizás necesite utilizar la opción <code>-T</code> si <code>/tmp</code> está en una pequeña partición de raíz.) Consulta también la nota acerca de <code>LC_ALL</code> y las opciones de <code>sort</code>, <code>-u</code> (dejado de lado para clarificar más abajo).</p>
<pre class="sh"><code>  cat a b | sort | uniq &gt; c   # c es a unido con b
  cat a b | sort | uniq -d &gt; c   # c es a intersectado con b
  cat a b b | sort | uniq -u &gt; c   # c es el conjunto diferencia a - b</code></pre></li>
<li><p>Usa <code>grep . *</code> para rápidamente examinar el contenido de todos los archivos de un directorio (para que cada línea este emparejada con con el nombre de archivo), o <code>head -100 *</code> (para que cada archivo tenga un encabezado). Esto puede se útil para directorios llenos con ajustes de configuración como aquellos en <code>/sys</code>, <code>/proc</code>, <code>/etc</code>.</p></li>
<li><p>Sumar todos los números en la tercera columna de un archivo de texto (esto es probablemente 3 veces más rápido y 3 veces menos código que el equivalente en Python):</p>
<pre class="sh"><code>  awk &#39;{ x += $3 } END { print x }&#39; miarchivo</code></pre></li>
<li><p>Si quiere examinar tamaños/fechas en un árbol de archivos, esto es como un <code>ls -l</code> recursivo pero es más fácil de leer que <code>ls -lR</code>:</p>
<pre class="sh"><code>  find . -type f -ls</code></pre></li>
<li><p>Digamos que tiene un archivo de texto, como un log de un servidor web, y un cierto valor comienza a aparecer en algunas líneas, tales como un parámetro <code>acct_id</code> que está presente en la URL. Si quieres un recuento de cuantas peticiones por cada <code>acct_id</code>:</p>
<pre class="sh"><code>  cat access.log | egrep -o &#39;acct_id=[0-9]+&#39; | cut -d= -f2 | sort | uniq -c | sort -rn</code></pre></li>
<li><p>Para monitorear continuamente los cambios, usa <code>watch</code>, Ej. verificar los cambios de archivos en un directorio con <code>watch -d -n 2 'ls -rt1h | tail'</code> o para configuraciones de red mientras solucionas problemas con la configuración wifi <code>watch -d -n 2 ifconfig</code>.</p></li>
<li><p>Ejecuta esta función para obtener un consejo aleatorio desde este documento (analiza el Markdown y extrae un elemento):</p>
<pre class="sh"><code>  function taocl() {
    curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README.md |
      pandoc -f markdown -t html |
      xmlstarlet fo --html --dropdtd |
      xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; |
      xmlstarlet unesc | fmt -80
  }</code></pre></li>
</ul>
<h2 id="obscuro-pero-útil">Obscuro, pero útil</h2>
<ul>
<li><p><code>expr</code>: ejecuta operaciones aritméticas o booleanas o evalúa expresiones regulares</p></li>
<li><p><code>m4</code>: procesador de macro sencillo</p></li>
<li><p><code>yes</code>: imprime un string sin fin</p></li>
<li><p><code>cal</code>: lindo calendario</p></li>
<li><p><code>env</code>: ejecuta un comando (útil en scripts)</p></li>
<li><p><code>printenv</code>: imprime las variables del entorno (útil en depuración y scripts)</p></li>
<li><p><code>look</code>: buscar palabras en inglés (o líneas en un archivo) comenzando con un string</p></li>
<li><p><code>cut</code>, <code>paste</code> y <code>join</code>: manipulación de datos</p></li>
<li><p><code>fmt</code>: formatea los párrafos de texto</p></li>
<li><p><code>pr</code>: formatea el texto en páginas/columnas</p></li>
<li><p><code>fold</code>: ajusta de líneas de texto</p></li>
<li><p><code>column</code>: formatea campos de texto alineados, en columnas de ancho fijo o tablas</p></li>
<li><p><code>expand</code> y <code>unexpand</code>: conversión entre tabuladores y espacios</p></li>
<li><p><code>nl</code>: agrega números de línea</p></li>
<li><p><code>seq</code>: imprime números</p></li>
<li><p><code>bc</code>: calculadora</p></li>
<li><p><code>factor</code>: factorización de enteros</p></li>
<li><p><a href="https://gnupg.org/"><code>gpg</code></a>: encripta y firma archivos</p></li>
<li><p><code>toe</code>: tabla de información de términos</p></li>
<li><p><code>nc</code>: depuración de la red y transferencia de datos</p></li>
<li><p><code>socat</code>: socket relay y redireccionador de puerto tcp (similar a <code>netcat</code>)</p></li>
<li><p><a href="https://github.com/mattthias/slurm"><code>slurm</code></a>: visualización del tráfico de red</p></li>
<li><p><code>dd</code>: moviliza datos entre archivos o dispositivos</p></li>
<li><p><code>file</code>: identifica el tipo de archivo</p></li>
<li><p><code>tree</code>: muestra directorios y subdirectorios como un árbol anidado; parecido a <code>ls</code> pero recursivo</p></li>
<li><p><code>stat</code>: información del archivo</p></li>
<li><p><code>time</code>: ejecuta y calcula el tiempo de ejecución de un comando</p></li>
<li><p><code>timeout</code>: ejecuta un comando especificando una cantidad de tiempo y deteniendo el proceso cuando la cantidad de tiempo especificado se completa.</p></li>
<li><p><code>lockfile</code>: crea un archivo semáforo que puedes solo ser removido con <code>rm -f</code></p></li>
<li><p><code>logrotate</code>: rota, comprime y registra correos electrónicos.</p></li>
<li><p><code>watch</code>: ejecuta un comando repetidamente, mostrando resultados y/o resaltando cambios</p></li>
<li><p><code>tac</code>: imprime archivos en forma inversa</p></li>
<li><p><code>shuf</code>: selección aleatoria de líneas de un archivo</p></li>
<li><p><code>comm</code>: compara archivos ordenados línea por línea</p></li>
<li><p><code>pv</code>: monitorea el progreso de datos a través de un tubo</p></li>
<li><p><code>hd</code>, <code>hexdump</code>, <code>xxd</code>, <code>bview</code> y <code>bvi</code>: descarga o edita archivos binarios</p></li>
<li><p><code>strings</code>: extrae texto desde archivos binarios</p></li>
<li><p><code>tr</code>: traducción o manipulación de caracteres</p></li>
<li><p><code>iconv</code> o <code>uconv</code>: conversión de codificaciones de texto</p></li>
<li><p><code>split</code> y <code>csplit</code>: división de archivos</p></li>
<li><p><code>sponge</code>: lee todas las entradas antes de escribirlo, útil para vista previa y posterior escritura sobre el mismo archivo, Ej., <code>grep -v something some-file | sponge some-file</code></p></li>
<li><p><code>units</code>: unidades de conversión y cálculos; convierte furlongs por fortnight a twips por blink (ver también <code>/usr/share/units/definitions.units</code>)</p></li>
<li><p><code>apg</code>: genera contraseñas aleatorias.</p></li>
<li><p><code>7z</code>: compresión de archivos de alto nivel</p></li>
<li><p><code>ldd</code>: información de librería dinámica</p></li>
<li><p><code>nm</code>: símbolos de archvios objeto</p></li>
<li><p><code>ab</code>: benchmarking de servidores web</p></li>
<li><p><code>strace</code>: depuración de llamadas del sistema</p></li>
<li><p><code>mtr</code>: mejor traceroute para la depuración de la red</p></li>
<li><p><code>cssh</code>: shell concurrente visual</p></li>
<li><p><code>rsync</code>: sincronización de archivos y carpetas sobre SSH o en sistema de archivos locales</p></li>
<li><p><code>wireshark</code> y <code>tshark</code>: captura de paquetes y depuración de la red</p></li>
<li><p><code>ngrep</code>: grep para la capa de la red</p></li>
<li><p><code>host</code> y <code>dig</code>: consultas DNS</p></li>
<li><p><code>lsof</code>: descriptor de archivo de procesos e información de socket</p></li>
<li><p><code>dstat</code>: sistema de estadísticas útil</p></li>
<li><p><a href="https://github.com/nicolargo/glances"><code>glances</code></a>: visión general de multi-subsistemas, de alto nivel</p></li>
<li><p><code>iostat</code>: estadísticas del uso del disco duro</p></li>
<li><p><code>mpstat</code>: estadísticas del uso del CPU</p></li>
<li><p><code>vmstat</code>: estadísticas del uso de la memoria</p></li>
<li><p><code>htop</code>: versión mejorada de top</p></li>
<li><p><code>last</code>: historial de login</p></li>
<li><p><code>w</code>: quién está autenticado</p></li>
<li><p><code>id</code>: información de identidad de usuario/grupo</p></li>
<li><p><code>sar</code>: estadísticas históricas del sistema</p></li>
<li><p><code>iftop</code> o <code>nethogs</code>: utilización de la red por un socket o proceso</p></li>
<li><p><code>ss</code>: estadísticas de socket</p></li>
<li><p><code>dmesg</code>: mensajes de error del arranque y del sistema</p></li>
<li><p><code>sysctl</code>: examina y configura los parámetros de kernel de Linux en tiempo de ejecución</p></li>
<li><p><code>hdparm</code>: manipulación/rendimiento de discos SATA/ATA</p></li>
<li><p><code>lsb_release</code>: información de la distribución de Linux</p></li>
<li><p><code>lsblk</code>: lista de dispositivos de bloque: una vista tipo arbol de sus discos y particiones de disco</p></li>
<li><p><code>lshw</code>, <code>lscpu</code>, <code>lspci</code>, <code>lsusb</code>, <code>dmidecode</code>: información de hardware, incluyendo CPU, BIOS, RAID, gráficos, dispositivos, etc</p></li>
<li><p><code>lsmod</code> y <code>modinfo</code>: lista y muestra detalles de los módulos del kernel</p></li>
<li><p><code>fortune</code>, <code>ddate</code>, y <code>sl</code>: um, bien, depende de si considera las locomotoras de vapor y citas Zippy &quot;útiles&quot;</p></li>
</ul>
<h2 id="solo-para-os-x">Solo para OS X</h2>
<p>Estos son puntos relevantes <em>únicamente</em> para MacOS.</p>
<ul>
<li><p>Administración de paquetes con <code>brew</code> (Homebrew) y/o <code>port</code> (MacPorts). Estos pueden ser utilizados para instalar en MacOS muchos de los comandos de arriba.</p></li>
<li><p>Copie la salida de cualquier comando en una aplicación de escritorio con <code>pbcopy</code> y pegue una entrada con <code>pbpaste</code>.</p></li>
<li><p>Para activar la teacla Option en un Terminal Mac OS Terminal como una tecla alt (tal como se usan en los comandos más arriba como <strong>alt-b</strong>, <strong>alt-f</strong>, etc.), abre Preferencias -&gt; Perfiles -&gt; Teclado y selecciona &quot;Usa Option como tecla Meta&quot;.</p></li>
<li><p>Para abrir un archivo con una aplicación de escritorio, use <code>open</code> o <code>open -a /Applications/Whatever.app</code>.</p></li>
<li><p>Spotlight: Busque archivos con <code>mdfind</code> y liste metadata (tal como información de foto EXIF) con <code>mdls</code>.</p></li>
<li><p>Ten en cuenta que MacOS está basado en BSD Unix, y muchos comandos (por ejemplo <code>ps</code>, <code>ls</code>, <code>tail</code>, <code>awk</code>, <code>sed</code>) tiene sutiles variaciones en comparación con Linux, que está en gran parte influenciado por el sistema Unix V-style y herramientas GNU. Comunmente se puede diferenciar al notar que una página man tienen el encabezado &quot;BSD General Commands Manual.&quot; En algunos casos versiones GNU pueden ser instaladas también (tales como <code>gawk</code> y <code>gsed</code> para GNU awk y sed). Si escribe Bash scripts multiplataforma, evite tales comandos (por ejemplo, considere Python o <code>perl</code>) o prueba cuidadosamente.</p></li>
<li><p>Para obtener la información de la versión del MacOS, usa <code>sw_vers</code>.</p></li>
</ul>
<h2 id="más-recursos">Más recursos</h2>
<ul>
<li><a href="https://github.com/alebcay/awesome-shell">awesome-shell</a>: Una lista curada de herramientas shell y recursos.</li>
<li><a href="https://github.com/herrbischoff/awesome-osx-command-line">awesome-osx-command-line</a>: Una guía más detallada para la línea de comandos del Mac OS.</li>
<li><a href="http://redsymbol.net/articles/unofficial-bash-strict-mode/">Strict mode</a> para escribir mejores script shell.</li>
<li><a href="https://github.com/koalaman/shellcheck">shellcheck</a>: Una herramienta de análisis estadístico del script shell. Esencialmente, lint para bash/sh/zsh.</li>
<li><a href="http://www.dwheeler.com/essays/filenames-in-shell.html">Filenames and Pathnames in Shell</a>: Las menudencias tristemente complejas sobre cómo manejar nombres de archivos correctamente en shell scripts.</li>
</ul>
<h2 id="advertencia">Advertencia</h2>
<p>Con la excepción de tareas muy pequeñas, el código está escrito para que otros puedan leerlo. Con el poder llega la responsabilidad. El hecho de que <em>puedes</em> hacer algo en Bash no necesariamente significa que deba hacerlo! ;)</p>
<h2 id="licencia">Licencia</h2>
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" alt="Creative Commons License" /></a></p>
<p>Este trabajo está licenciado bajo <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
